{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/E:/Repos/1JS/ooui/packages/office-online-ccp/lib/copyPasteService.js","webpack://[name]/E:/Repos/1JS/ooui/packages/office-online-ccp/lib/fileReaderEx.js","webpack://[name]/E:/Repos/1JS/ooui/packages/office-online-ccp/lib/getClipboardDataReturnValue.js","webpack://[name]/E:/Repos/1JS/ooui/packages/office-online-ccp/lib/imageReader.js","webpack://[name]/E:/Repos/1JS/ooui/packages/office-online-ccp/lib/index.js","webpack://[name]/./src/CopyPasteMessageListener.ts","webpack://[name]/./src/background.ts"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAA4E;AACrE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wFAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,qBAAqB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,aAAa;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,aAAa;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,mBAAmB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,aAAa;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,4BAA4B;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wFAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6HAA6H,aAAa;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACnNA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;AClCA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;ACVA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACJ;AACD;AAC9B,iC;;;;;;;;;;;;ACHA;AAAA;AAAA;AAA0D;AAE1D;IAGE,kCAAY,gBAAkC;QAC5C,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7D,CAAC;IAED;;;OAGG;IACI,oDAAiB,GAAxB,UACE,OAAY,EACZ,MAAoC,EACpC,YAAsC;QAEtC,QAAQ,OAAO,CAAC,OAAO,EAAE;YACvB,KAAK,uEAAgB,CAAC,WAAW;gBAC/B,OAAO,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAC5C,OAAO,EACP,MAAM,EACN,YAAY,CACb,CAAC;YACJ,KAAK,uEAAgB,CAAC,YAAY;gBAChC,OAAO,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,CAC7C,OAAO,EACP,MAAM,EACN,YAAY,CACb,CAAC;YACJ,KAAK,uEAAgB,CAAC,uBAAuB;gBAC3C,OAAO,IAAI,CAAC,gBAAgB,CAAC,6BAA6B,CACxD,OAAO,EACP,MAAM,EACN,YAAY,CACb,CAAC;YACJ,KAAK,uEAAgB,CAAC,2BAA2B;gBAC/C,OAAO,IAAI,CAAC,gBAAgB,CAAC,0BAA0B,CACrD,OAAO,EACP,MAAM,EACN,YAAY,CACb,CAAC;YACJ;gBACE,OAAO,KAAK,CAAC;SAChB;IACH,CAAC;IACH,+BAAC;AAAD,CAAC;;;;;;;;;;;;;;AChDD;AAAA;AAAA;AAIgC;AACsC;AAEtE,IAAM,UAAU,GAAiB,IAAI,mEAAY,EAAE,CAAC;AACpD,IAAM,WAAW,GAAgB,IAAI,kEAAW,CAAC,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;AAChF,IAAM,gBAAgB,GAAqB,IAAI,uEAAgB,CAC7D,IAAI,CAAC,YAAY,EACjB,WAAW,EACX,MAAM,CACP,CAAC;AACF,IAAM,wBAAwB,GAC5B,IAAI,kFAAwB,CAAC,gBAAgB,CAAC,CAAC;AACjD,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,WAAW,CAC1C,wBAAwB,CAAC,iBAAiB,CAC3C,CAAC","file":"background.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/background.ts\");\n","import { GetClipboardDataReturnValue } from \"./getClipboardDataReturnValue\";\r\nexport class CopyPasteService {\r\n    constructor(logger, imageReader, window) {\r\n        this.availableCommands = [\r\n            CopyPasteService.testCommand,\r\n            CopyPasteService.pasteCommand,\r\n            CopyPasteService.getClipboardDataCommand,\r\n            CopyPasteService.getAvailableCommandsCommand,\r\n        ];\r\n        // Event listener to get image files from paste event object.\r\n        this.onPasteEventImage = (event) => {\r\n            this.imageBlobs = [];\r\n            if (event.clipboardData === null) {\r\n                return;\r\n            }\r\n            const items = event.clipboardData.items;\r\n            for (let i = 0; i < items.length; i += 1) {\r\n                if (this.imageReader.isImageFile(items[i])) {\r\n                    const file = this.imageReader.getAsFile(items[i]);\r\n                    if (file != null)\r\n                        this.imageBlobs.push(file);\r\n                }\r\n            }\r\n        };\r\n        // Try to get image blobs, HTML, and plain text from event.\r\n        // HTML and plain text are set on this.clipboardData immediately.\r\n        // Image is set on this.clipboardData by this.imageReader.\r\n        this.getClipboardData = (event) => {\r\n            if (event.clipboardData === null)\r\n                return;\r\n            this.onPasteEventImage(event);\r\n            if (event.clipboardData.types.indexOf(\"text/html\") !== -1) {\r\n                this.clipboardData.html = event.clipboardData.getData(\"text/html\");\r\n            }\r\n            if (event.clipboardData.types.indexOf(\"text/plain\") !== -1) {\r\n                this.clipboardData.text = event.clipboardData.getData(\"text/plain\");\r\n            }\r\n            if (event.clipboardData.types.indexOf(\"ppt/slides\") !== -1) {\r\n                this.clipboardData.pptSlide = event.clipboardData.getData(\"ppt/slides\");\r\n            }\r\n            if (event.clipboardData.types.indexOf(\"ppt/objectmetadata\") !== -1) {\r\n                this.clipboardData.pptObjectMetaData =\r\n                    event.clipboardData.getData(\"ppt/objectmetadata\");\r\n            }\r\n            if (event.clipboardData.types.indexOf(\"ppt/objectdata\") !== -1) {\r\n                this.clipboardData.pptObjectData =\r\n                    event.clipboardData.getData(\"ppt/objectdata\");\r\n            }\r\n        };\r\n        // Event listener to get image, plain text, or HTML from paste event object.\r\n        this.onPasteEventGetClipboardData = (event) => {\r\n            this.getClipboardData(event);\r\n            // Stop browser from modifying DOM\r\n            event.preventDefault();\r\n        };\r\n        this.logger = logger;\r\n        this.imageReader = imageReader;\r\n        this.window = window;\r\n        this.imageBlobs = [];\r\n        this.clipboardData = new GetClipboardDataReturnValue();\r\n    }\r\n    isTrustedSender(sender) {\r\n        var _a;\r\n        try {\r\n            if (sender === null || sender.url === undefined)\r\n                return false;\r\n            const senderUrl = new URL(sender.url);\r\n            if (senderUrl.origin === null)\r\n                return false;\r\n            const domainMatch = senderUrl.origin.match(/^https:\\/\\/((.*?(word-edit|powerpoint|onenote|excel|visio)\\.(officeapps\\.live\\.com|partner\\.officewebapps\\.cn|gov\\.online\\.office365\\.us|dod\\.online\\.office365\\.us))|(project\\.microsoft\\.com)|(.*?(whiteboard\\.microsoft\\.com))|(whiteboard\\.(office\\.com|office365\\.us|apps\\.mil)))$/g);\r\n            if (domainMatch === null) {\r\n                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trackEvent(\"copypaste_untrusted\", { sender: sender.url });\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    // Inform caller what functions can be called\r\n    handleGetAvailableCommands(_message, sender, sendResponse) {\r\n        var _a;\r\n        if (!this.isTrustedSender(sender)) {\r\n            return false;\r\n        }\r\n        try {\r\n            sendResponse(this.availableCommands);\r\n        }\r\n        catch (e) {\r\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`handleGetAvailableCommands() - Exception: ${e.toString()}`);\r\n        }\r\n        return false;\r\n    }\r\n    // Respond to clients so they know of our existence.\r\n    handleTestCommand(message, sender, sendResponse) {\r\n        var _a, _b;\r\n        if (!this.isTrustedSender(sender)) {\r\n            return false;\r\n        }\r\n        try {\r\n            sendResponse(message.object);\r\n        }\r\n        catch (e) {\r\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`handleTestCommand() - Exception: ${e.toString()}`);\r\n        }\r\n        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.trackEvent(\"CopyPaste_Test\");\r\n        return false;\r\n    }\r\n    // Copy client's data into system clipboard.\r\n    handleCopyCommand(_message, sender, _sendResponse) {\r\n        var _a;\r\n        if (!this.isTrustedSender(sender)) {\r\n            return false;\r\n        }\r\n        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trackEvent(\"CopyPaste_Copy\", { deprecated: true });\r\n        return false;\r\n    }\r\n    // Fetch data from system clipboard and return to client.\r\n    handlePasteCommand(_message, sender, sendResponse) {\r\n        var _a, _b;\r\n        if (!this.isTrustedSender(sender)) {\r\n            return false;\r\n        }\r\n        let retVal = false;\r\n        let sandbox = null;\r\n        try {\r\n            sandbox = this.getCopyPasteSandbox();\r\n            // Setting innerHTML to empty string is safe\r\n            // tslint:disable-next-line:no-inner-html\r\n            sandbox.innerHTML = \"\";\r\n            sandbox.focus();\r\n            document.execCommand(\"selectAll\");\r\n            this.window.addEventListener(\"paste\", this.onPasteEventImage);\r\n            if (document.execCommand(\"paste\")) {\r\n                // First try to fetch image data from browser, then try send back the original image src\r\n                if (this.imageBlobs.length > 0) {\r\n                    this.imageReader.readImages(this.imageBlobs, function (imageHtml) {\r\n                        sendResponse(imageHtml);\r\n                    });\r\n                    retVal = true;\r\n                }\r\n                else {\r\n                    // This also handles the empty situation:\r\n                    //    1. Copy an image from Windows Photo Viewer (or similar software);\r\n                    //    2. Then paste in PPT online doc using context menu;\r\n                    //    3. Browser won't paste anything into sandbox.\r\n                    sendResponse(sandbox.innerHTML);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`handlePasteCommand() - Exception: ${e.toString()}`);\r\n        }\r\n        if (sandbox !== null) {\r\n            // Setting innerHTML to empty string is safe\r\n            // tslint:disable-next-line:no-inner-html\r\n            sandbox.innerHTML = \"\";\r\n        }\r\n        this.window.removeEventListener(\"paste\", this.onPasteEventImage);\r\n        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.trackEvent(\"CopyPaste_Paste\", { IsPrefetchedImage: retVal });\r\n        return retVal;\r\n    }\r\n    // Fetch data from system clipboard without modifying DOM\r\n    handleGetClipboardDataCommand(_message, sender, sendResponse) {\r\n        var _a;\r\n        if (!this.isTrustedSender(sender)) {\r\n            return false;\r\n        }\r\n        // Indicates if sendResponse will be called asynchronously\r\n        let retVal = false;\r\n        let sandbox = null;\r\n        try {\r\n            sandbox = this.getCopyPasteSandbox();\r\n            sandbox.focus();\r\n            this.clipboardData = new GetClipboardDataReturnValue();\r\n            this.window.addEventListener(\"paste\", this.onPasteEventGetClipboardData);\r\n            if (document.execCommand(\"paste\")) {\r\n                // First try to fetch image data from browser, then try send back the original image src\r\n                if (this.imageBlobs.length > 0) {\r\n                    this.imageReader.readImages(this.imageBlobs, (imageHtml) => {\r\n                        this.clipboardData.img = imageHtml;\r\n                        sendResponse(this.clipboardData);\r\n                    });\r\n                    retVal = true;\r\n                }\r\n                else {\r\n                    sendResponse(this.clipboardData);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`handleGetClipboardDataCommand() - Exception: ${e.toString()}`);\r\n        }\r\n        this.window.removeEventListener(\"paste\", this.onPasteEventGetClipboardData);\r\n        return retVal;\r\n    }\r\n    getCopyPasteSandbox() {\r\n        let sandbox = document.getElementById(\"copyPasteSandbox\");\r\n        if (!sandbox) {\r\n            const elem = document.createElement(\"div\");\r\n            elem.contentEditable = true;\r\n            sandbox = document.body.appendChild(elem);\r\n        }\r\n        return sandbox;\r\n    }\r\n}\r\nCopyPasteService.testCommand = \"test\";\r\nCopyPasteService.pasteCommand = \"paste\";\r\nCopyPasteService.getClipboardDataCommand = \"getClipboardData\";\r\nCopyPasteService.getAvailableCommandsCommand = \"getAvailableCommands\";\r\n//# sourceMappingURL=copyPasteService.js.map","export class FileReaderEx {\r\n    constructor() {\r\n        this.onloadend = null;\r\n        this.onerror = null;\r\n        this.onabort = null;\r\n        this.reader = undefined;\r\n        // delegates file read events to client provided handler.\r\n        this.onloadendInternal = (event) => {\r\n            if (this.onloadend !== null)\r\n                this.onloadend(event);\r\n        };\r\n        this.onabortInternal = (event) => {\r\n            if (this.onabort !== null)\r\n                this.onabort(event);\r\n        };\r\n        this.onerrorInternal = (event) => {\r\n            if (this.onerror !== null)\r\n                this.onerror(event);\r\n        };\r\n    }\r\n    readAsDataURL(blob) {\r\n        if (this.reader === undefined) {\r\n            this.reader = new FileReader();\r\n            this.reader.onloadend = this.onloadendInternal;\r\n            this.reader.onabort = this.onabortInternal;\r\n            this.reader.onerror = this.onerrorInternal;\r\n        }\r\n        if (this.reader !== undefined)\r\n            this.reader.readAsDataURL(blob);\r\n    }\r\n    isBlob(obj) {\r\n        return obj && obj instanceof Blob;\r\n    }\r\n}\r\n//# sourceMappingURL=fileReaderEx.js.map","export class GetClipboardDataReturnValue {\r\n    constructor() {\r\n        this.img = \"\";\r\n        this.html = \"\";\r\n        this.text = \"\";\r\n        this.pptSlide = \"\";\r\n        this.pptObjectMetaData = \"\";\r\n        this.pptObjectData = \"\";\r\n    }\r\n}\r\n//# sourceMappingURL=getClipboardDataReturnValue.js.map","export class ImageReader {\r\n    constructor(logger, FileReaderEx) {\r\n        this.fileReaderHandlersDefined = false;\r\n        this.onLoadEnd = (event) => {\r\n            if (event.target !== null && event.target.result !== null) {\r\n                this.imageHtml += '<img src=\"' + event.target.result + '\">';\r\n            }\r\n            this.readImage();\r\n        };\r\n        // when error happens, we try to read remaining available blobs if possible\r\n        this.onAbort = (_event) => {\r\n            var _a;\r\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(\"imageReader::onAbort() - readAsDataURL was aborted.\");\r\n            this.readImage();\r\n        };\r\n        this.onError = (_event) => {\r\n            var _a;\r\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(\"imageReader::onError() - error happens in readAsDataURL()\");\r\n            this.readImage();\r\n        };\r\n        this.logger = logger;\r\n        this.FileReaderEx = FileReaderEx;\r\n        this.imageBlobs = [];\r\n        this.imageHtmlCallback = (_imageHtml) => { };\r\n        this.imageHtml = \"\";\r\n    }\r\n    // client's responsibility to ensure parameter validity\r\n    isImageFile(item) {\r\n        return item.kind === \"file\" && item.type.indexOf(\"image/\") !== -1;\r\n    }\r\n    getAsFile(item) {\r\n        return item.getAsFile();\r\n    }\r\n    readImages(blobs, callback) {\r\n        this.imageBlobs = blobs;\r\n        this.imageHtmlCallback = callback;\r\n        this.imageHtml = \"\";\r\n        if (!this.fileReaderHandlersDefined) {\r\n            this.FileReaderEx.onloadend = this.onLoadEnd;\r\n            this.FileReaderEx.onabort = this.onAbort;\r\n            this.FileReaderEx.onerror = this.onError;\r\n            this.fileReaderHandlersDefined = true;\r\n        }\r\n        this.readImage();\r\n    }\r\n    readImage() {\r\n        if (this.imageBlobs.length === 0) {\r\n            this.imageHtmlCallback(this.imageHtml);\r\n        }\r\n        else {\r\n            const imageBlob = this.imageBlobs.shift();\r\n            if (!this.FileReaderEx.isBlob(imageBlob)) {\r\n                this.readImage();\r\n                return;\r\n            }\r\n            this.FileReaderEx.readAsDataURL(imageBlob);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=imageReader.js.map","export * from \"./copyPasteService\";\r\nexport * from \"./fileReaderEx\";\r\nexport * from \"./imageReader\";\r\n//# sourceMappingURL=index.js.map","import { CopyPasteService } from \"@1js/office-online-ccp\";\r\n\r\nexport class CopyPasteMessageListener {\r\n  private readonly copyPasteService: CopyPasteService;\r\n\r\n  constructor(copyPasteService: CopyPasteService) {\r\n    this.copyPasteService = copyPasteService;\r\n    this.onMessageExternal = this.onMessageExternal.bind(this);\r\n  }\r\n\r\n  /* Event listener to response external message from Office Online.\r\n   * Returns a boolean indicating if sendResponse becomes invalid after this event listener returns\r\n   * (i.e. if sendResponse will be called asynchronously)\r\n   */\r\n  public onMessageExternal(\r\n    message: any,\r\n    sender: chrome.runtime.MessageSender,\r\n    sendResponse: (response?: any) => void\r\n  ) {\r\n    switch (message.command) {\r\n      case CopyPasteService.testCommand:\r\n        return this.copyPasteService.handleTestCommand(\r\n          message,\r\n          sender,\r\n          sendResponse\r\n        );\r\n      case CopyPasteService.pasteCommand:\r\n        return this.copyPasteService.handlePasteCommand(\r\n          message,\r\n          sender,\r\n          sendResponse\r\n        );\r\n      case CopyPasteService.getClipboardDataCommand:\r\n        return this.copyPasteService.handleGetClipboardDataCommand(\r\n          message,\r\n          sender,\r\n          sendResponse\r\n        );\r\n      case CopyPasteService.getAvailableCommandsCommand:\r\n        return this.copyPasteService.handleGetAvailableCommands(\r\n          message,\r\n          sender,\r\n          sendResponse\r\n        );\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}\r\n","import {\r\n  CopyPasteService,\r\n  ImageReader,\r\n  FileReaderEx,\r\n} from \"@1js/office-online-ccp\";\r\nimport { CopyPasteMessageListener } from \"./CopyPasteMessageListener\";\r\n\r\nconst fileReader: FileReaderEx = new FileReaderEx();\r\nconst imageReader: ImageReader = new ImageReader(null /* logger */, fileReader);\r\nconst copyPasteService: CopyPasteService = new CopyPasteService(\r\n  null /* logger */,\r\n  imageReader,\r\n  window\r\n);\r\nconst copyPasteMessageListener: CopyPasteMessageListener =\r\n  new CopyPasteMessageListener(copyPasteService);\r\nchrome.runtime.onMessageExternal.addListener(\r\n  copyPasteMessageListener.onMessageExternal\r\n);\r\n"],"sourceRoot":""}